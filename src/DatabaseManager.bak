import * as sqlite3 from 'sqlite3';
import { promisify } from 'util';
import * as fs from 'fs';
import * as path from 'path';
import { Logger } from './logger';

/**
 * Image record interface matching database schema
 */
export interface ImageRecord {
  id?: number;
  url: string;
  alt_text?: string;
  filename: string;
  file_path: string;
  file_size: number;
  width: number;
  height: number;
  keyword: string;
  category?: string;
  download_date?: string;
  processed: boolean;
  processing_date?: string;
}

/**
 * Collection statistics record interface
 */
export interface CollectionStats {
  id?: number;
  keyword: string;
  total_found: number;
  downloaded: number;
  processed: number;
  failed_downloads: number;
  failed_processing: number;
  collection_date?: string;
}

/**
 * Database query filters for images
 */
export interface ImageFilters {
  keyword?: string;
  category?: string;
  processed?: boolean;
  minWidth?: number;
  minHeight?: number;
  maxFileSize?: number;
}

/**
 * DatabaseManager class for handling all database operations
 * Uses better-sqlite3 for high-performance SQLite operations
 */
export class DatabaseManager {
  private db: sqlite3.Database;
  private dbRun: (sql: string, params?: any[]) => Promise<sqlite3.RunResult>;
  private dbGet: (sql: string, params?: any[]) => Promise<any>;
  private dbAll: (sql: string, params?: any[]) => Promise<any[]>;
  private logger: Logger;
  private dbPath: string;

  constructor(dbPath: string = './database/images.db') {
    this.dbPath = dbPath;
    this.logger = new Logger('DatabaseManager');
    
    // Ensure database directory exists
    const dbDir = path.dirname(dbPath);
    if (!fs.existsSync(dbDir)) {
      fs.mkdirSync(dbDir, { recursive: true });
    }

    // Initialize database
    this.db = new Database(dbPath);
    this.initializeDatabase();
    this.logger.info(`Database initialized: ${dbPath}`);
  }

  /**
   * Initialize database tables and indexes
   */
  private initializeDatabase(): void {
    // Enable foreign keys and WAL mode for better performance
    this.db.pragma('foreign_keys = ON');
    this.db.pragma('journal_mode = WAL');
    this.db.pragma('synchronous = NORMAL');
    this.db.pragma('cache_size = 1000');

    // Create images table
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS images (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        url TEXT NOT NULL UNIQUE,
        alt_text TEXT,
        filename TEXT NOT NULL UNIQUE,
        file_path TEXT NOT NULL,
        file_size INTEGER NOT NULL,
        width INTEGER NOT NULL,
        height INTEGER NOT NULL,
        keyword TEXT NOT NULL,
        category TEXT,
        download_date DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
        processed BOOLEAN NOT NULL DEFAULT 0,
        processing_date DATETIME
      )
    `);

    // Create collection_stats table
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS collection_stats (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        keyword TEXT NOT NULL,
        total_found INTEGER NOT NULL,
        downloaded INTEGER NOT NULL,
        processed INTEGER NOT NULL,
        failed_downloads INTEGER NOT NULL DEFAULT 0,
        failed_processing INTEGER NOT NULL DEFAULT 0,
        collection_date DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Create indexes for better query performance
    this.db.exec(`
      CREATE INDEX IF NOT EXISTS idx_keyword ON images(keyword);
      CREATE INDEX IF NOT EXISTS idx_category ON images(category);
      CREATE INDEX IF NOT EXISTS idx_processed ON images(processed);
      CREATE INDEX IF NOT EXISTS idx_keyword_stats ON collection_stats(keyword);
    `);

    this.logger.debug('Database tables and indexes created/verified');
  }

  /**
   * Insert a new image record
   */
  insertImage(image: Omit<ImageRecord, 'id' | 'download_date'>): number {
    const stmt = this.db.prepare(`
      INSERT INTO images (
        url, alt_text, filename, file_path, file_size, 
        width, height, keyword, category, processed, processing_date
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    try {
      const result = stmt.run(
        image.url,
        image.alt_text || null,
        image.filename,
        image.file_path,
        image.file_size,
        image.width,
        image.height,
        image.keyword,
        image.category || null,
        image.processed ? 1 : 0,
        image.processing_date || null
      );

      this.logger.debug(`Inserted image record with ID: ${result.lastInsertRowid}`);
      return result.lastInsertRowid as number;
    } catch (error) {
      this.logger.error(`Failed to insert image record:`, error);
      throw error;
    }
  }

  /**
   * Batch insert multiple image records
   */
  batchInsertImages(images: Array<Omit<ImageRecord, 'id' | 'download_date'>>): number[] {
    const stmt = this.db.prepare(`
      INSERT INTO images (
        url, alt_text, filename, file_path, file_size, 
        width, height, keyword, category, processed, processing_date
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    const insertedIds: number[] = [];
    
    const transaction = this.db.transaction((imagesToInsert: typeof images) => {
      for (const image of imagesToInsert) {
        try {
          const result = stmt.run(
            image.url,
            image.alt_text || null,
            image.filename,
            image.file_path,
            image.file_size,
            image.width,
            image.height,
            image.keyword,
            image.category || null,
            image.processed ? 1 : 0,
            image.processing_date || null
          );
          insertedIds.push(result.lastInsertRowid as number);
        } catch (error) {
          this.logger.warn(`Failed to insert image: ${image.url}`, error);
        }
      }
    });

    try {
      transaction(images);
      this.logger.info(`Batch inserted ${insertedIds.length}/${images.length} image records`);
      return insertedIds;
    } catch (error) {
      this.logger.error('Failed to batch insert images:', error);
      throw error;
    }
  }

  /**
   * Update image processing status
   */
  updateImageProcessed(id: number, processed: boolean, processingDate?: string): boolean {
    const stmt = this.db.prepare(`
      UPDATE images 
      SET processed = ?, processing_date = ?
      WHERE id = ?
    `);

    try {
      const result = stmt.run(
        processed ? 1 : 0,
        processingDate || (processed ? new Date().toISOString() : null),
        id
      );

      const success = result.changes > 0;
      if (success) {
        this.logger.debug(`Updated image ${id} processed status to: ${processed}`);
      }
      return success;
    } catch (error) {
      this.logger.error(`Failed to update image ${id}:`, error);
      throw error;
    }
  }

  /**
   * Get image by ID
   */
  getImageById(id: number): ImageRecord | null {
    const stmt = this.db.prepare('SELECT * FROM images WHERE id = ?');
    
    try {
      const result = stmt.get(id) as ImageRecord | undefined;
      return result || null;
    } catch (error) {
      this.logger.error(`Failed to get image ${id}:`, error);
      throw error;
    }
  }

  /**
   * Get image by URL
   */
  getImageByUrl(url: string): ImageRecord | null {
    const stmt = this.db.prepare('SELECT * FROM images WHERE url = ?');
    
    try {
      const result = stmt.get(url) as ImageRecord | undefined;
      return result || null;
    } catch (error) {
      this.logger.error(`Failed to get image by URL:`, error);
      throw error;
    }
  }

  /**
   * Get images with filters
   */
  getImages(filters: ImageFilters = {}, limit?: number, offset?: number): ImageRecord[] {
    let sql = 'SELECT * FROM images WHERE 1=1';
    const params: any[] = [];

    // Apply filters
    if (filters.keyword) {
      sql += ' AND keyword = ?';
      params.push(filters.keyword);
    }

    if (filters.category) {
      sql += ' AND category = ?';
      params.push(filters.category);
    }

    if (filters.processed !== undefined) {
      sql += ' AND processed = ?';
      params.push(filters.processed ? 1 : 0);
    }

    if (filters.minWidth) {
      sql += ' AND width >= ?';
      params.push(filters.minWidth);
    }

    if (filters.minHeight) {
      sql += ' AND height >= ?';
      params.push(filters.minHeight);
    }

    if (filters.maxFileSize) {
      sql += ' AND file_size <= ?';
      params.push(filters.maxFileSize);
    }

    // Add ordering
    sql += ' ORDER BY download_date DESC';

    // Add pagination
    if (limit) {
      sql += ' LIMIT ?';
      params.push(limit);
      
      if (offset) {
        sql += ' OFFSET ?';
        params.push(offset);
      }
    }

    const stmt = this.db.prepare(sql);
    
    try {
      return stmt.all(...params) as ImageRecord[];
    } catch (error) {
      this.logger.error('Failed to get images with filters:', error);
      throw error;
    }
  }

  /**
   * Count images with filters
   */
  countImages(filters: ImageFilters = {}): number {
    let sql = 'SELECT COUNT(*) as count FROM images WHERE 1=1';
    const params: any[] = [];

    // Apply same filters as getImages
    if (filters.keyword) {
      sql += ' AND keyword = ?';
      params.push(filters.keyword);
    }

    if (filters.category) {
      sql += ' AND category = ?';
      params.push(filters.category);
    }

    if (filters.processed !== undefined) {
      sql += ' AND processed = ?';
      params.push(filters.processed ? 1 : 0);
    }

    if (filters.minWidth) {
      sql += ' AND width >= ?';
      params.push(filters.minWidth);
    }

    if (filters.minHeight) {
      sql += ' AND height >= ?';
      params.push(filters.minHeight);
    }

    if (filters.maxFileSize) {
      sql += ' AND file_size <= ?';
      params.push(filters.maxFileSize);
    }

    const stmt = this.db.prepare(sql);
    
    try {
      const result = stmt.get(...params) as { count: number };
      return result.count;
    } catch (error) {
      this.logger.error('Failed to count images:', error);
      throw error;
    }
  }

  /**
   * Insert collection statistics
   */
  insertCollectionStats(stats: Omit<CollectionStats, 'id' | 'collection_date'>): number {
    const stmt = this.db.prepare(`
      INSERT INTO collection_stats (
        keyword, total_found, downloaded, processed, 
        failed_downloads, failed_processing
      ) VALUES (?, ?, ?, ?, ?, ?)
    `);

    try {
      const result = stmt.run(
        stats.keyword,
        stats.total_found,
        stats.downloaded,
        stats.processed,
        stats.failed_downloads,
        stats.failed_processing
      );

      this.logger.debug(`Inserted collection stats for keyword: ${stats.keyword}`);
      return result.lastInsertRowid as number;
    } catch (error) {
      this.logger.error('Failed to insert collection stats:', error);
      throw error;
    }
  }

  /**
   * Get collection statistics by keyword
   */
  getCollectionStatsByKeyword(keyword: string): CollectionStats[] {
    const stmt = this.db.prepare(
      'SELECT * FROM collection_stats WHERE keyword = ? ORDER BY collection_date DESC'
    );
    
    try {
      return stmt.all(keyword) as CollectionStats[];
    } catch (error) {
      this.logger.error(`Failed to get collection stats for keyword ${keyword}:`, error);
      throw error;
    }
  }

  /**
   * Get overall collection summary
   */
  getCollectionSummary(): {
    totalImages: number;
    totalProcessed: number;
    totalUnprocessed: number;
    keywordStats: Array<{
      keyword: string;
      count: number;
      processed: number;
      avgFileSize: number;
    }>;
  } {
    try {
      // Get total counts
      const totalStmt = this.db.prepare(`
        SELECT 
          COUNT(*) as total,
          SUM(CASE WHEN processed = 1 THEN 1 ELSE 0 END) as processed,
          SUM(CASE WHEN processed = 0 THEN 1 ELSE 0 END) as unprocessed
        FROM images
      `);
      const totals = totalStmt.get() as {
        total: number;
        processed: number;
        unprocessed: number;
      };

      // Get keyword statistics
      const keywordStmt = this.db.prepare(`
        SELECT 
          keyword,
          COUNT(*) as count,
          SUM(CASE WHEN processed = 1 THEN 1 ELSE 0 END) as processed,
          AVG(file_size) as avgFileSize
        FROM images
        GROUP BY keyword
        ORDER BY count DESC
      `);
      const keywordStats = keywordStmt.all() as Array<{
        keyword: string;
        count: number;
        processed: number;
        avgFileSize: number;
      }>;

      return {
        totalImages: totals.total,
        totalProcessed: totals.processed,
        totalUnprocessed: totals.unprocessed,
        keywordStats
      };
    } catch (error) {
      this.logger.error('Failed to get collection summary:', error);
      throw error;
    }
  }

  /**
   * Delete image record
   */
  deleteImage(id: number): boolean {
    const stmt = this.db.prepare('DELETE FROM images WHERE id = ?');
    
    try {
      const result = stmt.run(id);
      const success = result.changes > 0;
      
      if (success) {
        this.logger.debug(`Deleted image record with ID: ${id}`);
      }
      
      return success;
    } catch (error) {
      this.logger.error(`Failed to delete image ${id}:`, error);
      throw error;
    }
  }

  /**
   * Check if URL already exists in database
   */
  urlExists(url: string): boolean {
    const stmt = this.db.prepare('SELECT 1 FROM images WHERE url = ? LIMIT 1');
    
    try {
      const result = stmt.get(url);
      return result !== undefined;
    } catch (error) {
      this.logger.error('Failed to check URL existence:', error);
      throw error;
    }
  }

  /**
   * Get database statistics
   */
  getDatabaseStats(): {
    totalImages: number;
    totalSize: number;
    tableInfo: Array<{
      name: string;
      rows: number;
    }>;
  } {
    try {
      const imageCount = this.db.prepare('SELECT COUNT(*) as count FROM images').get() as { count: number };
      const statsCount = this.db.prepare('SELECT COUNT(*) as count FROM collection_stats').get() as { count: number };
      const totalSize = this.db.prepare('SELECT SUM(file_size) as size FROM images').get() as { size: number };

      return {
        totalImages: imageCount.count,
        totalSize: totalSize.size || 0,
        tableInfo: [
          { name: 'images', rows: imageCount.count },
          { name: 'collection_stats', rows: statsCount.count }
        ]
      };
    } catch (error) {
      this.logger.error('Failed to get database stats:', error);
      throw error;
    }
  }

  /**
   * Backup database to a file
   */
  backup(backupPath: string): void {
    try {
      this.db.backup(backupPath);
      this.logger.info(`Database backed up to: ${backupPath}`);
    } catch (error) {
      this.logger.error('Failed to backup database:', error);
      throw error;
    }
  }

  /**
   * Optimize database (vacuum and analyze)
   */
  optimize(): void {
    try {
      this.db.exec('VACUUM');
      this.db.exec('ANALYZE');
      this.logger.info('Database optimized successfully');
    } catch (error) {
      this.logger.error('Failed to optimize database:', error);
      throw error;
    }
  }

  /**
   * Close database connection
   */
  close(): void {
    if (this.db) {
      this.db.close();
      this.logger.info('Database connection closed');
    }
  }

  /**
   * Get database path
   */
  getDatabasePath(): string {
    return this.dbPath;
  }
}